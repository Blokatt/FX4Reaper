desc: MonoCtrl (Blokatt)
//tags: korg monologue midi
//author: Jan Vorisek

/*
  .-============-.
  | MonoCtrl 1.0 |
  .-============-.
  .______________.
  
  An interface for the Korg Monologue synthesiser.
  
  Written by Blokatt (Jan Vorisek)
  (http://www.blokatt.net/, jan@blokatt.net, @blokatt)
  
  LOW PRECISION
  
  Setup for this track:
  ====================
  Input: MIDI - 
    'Monologue KBD/KNOB' (All channels! -> important for SysEx reasons)
  Routing -> Midi Hardware Output -
    'Monologue SOUND', enable low latency mode in Options -> Preferences -> Devices -> MIDI outputs
  
  Arm recording and enable monitoring.
  Make sure Tx/Rx MIDI is enabled in the global settings of your Monologue!
  ====================
        
  SysEx reverse-engineering made easier thanks to:
    - MIDI-OX (http://www.midiox.com/)
    - loopMIDI (https://www.tobias-erichsen.de/software/loopmidi.html)
    - Mido - MIDI Objects for Python (https://mido.readthedocs.io/en/latest/)
  
  ... and a whole lot of custom tools, all available at:
  https://github.com/Blokatt/FX4Reaper/tree/master/monoctrl      
  
  (one of the Python scripts contains a Monologue program dump documentation 
  in the form of comments, will put together a proper write-up in the future)
  
  05/02/19  
*/

slider1:s_channel=1<1,16,1>MIDI Channel
slider2:s_block_midi_passthrough=1<0,1,1{All events,CC/PC (all events during playback),CC and PC only}>MIDI Passthrough
slider3:s_send_pc_on_init=1:0<0,2,1{On program change and playback start,On program change only,Never (local preset)}>Auto-request program from synth
//================================//
slider5:s_program=1<1,100,1>Program
//================================//
slider7:s_vco1_wave=2<0,1,3{Square,Triangle,Sawtooth}>VCO1 Waveform
slider8:s_vco1_shape=0<0,127,1>VCO1 Shape
//================================//
slider10:s_vco2_wave=2<0,1,3{Noise,Triangle,Sawtooth}>VCO2 Waveform
slider11:s_vco2_shape=0<0,127,1>VCO2 Shape
slider12:s_vco2_pitch=0<-64,63,1>VCO2 Pitch
slider13:s_vco2_octave=0<-1,2,1>VCO2 Octave
//================================//
slider15:s_vco_mode=1<0,1,3{Ring,No sync,Sync}>Sync/Ring
//================================//
slider17:s_vco1_level=127<0,127,1>VCO1 Level
slider18:s_vco2_level=0<0,127,1>VCO2 Level
//================================//
slider20:s_filter_cutoff=127<0,127,1>Filter Cutoff
slider21:s_filter_resonance=0<0,127,1>Filter Resonance
//================================//
slider23:s_lfo_wave=1<0,1,3{Square,Triangle,Sawtooth}>LFO Wave
slider24:s_lfo_mode=1<0,1,3{One shot,Slow,Fast}>LFO Mode
slider25:s_lfo_rate=64<0,127,1>LFO Rate
slider26:s_lfo_intensity=0<-64,63,1>LFO Intensity
slider27:s_lfo_target=2<0,1,3{Cutoff,Shape,Pitch}>LFO Target
//================================//
slider29:s_eg_type=0<0,1,3{Gate,Attack/Gate/Decay,Attack/Decay}>EG Type
slider30:s_eg_attack=0<0,127,1>EG Attack
slider31:s_eg_decay=64<0,127,1>EG Decay
slider32:s_eg_intensity=0<-64,63,1>EG Intensity
slider33:s_eg_target=2<0,1,3{Cutoff,Pitch 2,Pitch}>EG Target
//================================//
slider35:s_drive=0<0,127,1>Drive

filename:0,logo.png
filename:1,background.png
filename:2,avatar.png
/////////////////////////////////////////////////////////////////////////////////
//////////////////// - A RATHER LARGE SECTION SEPARATOR. - //////////////////////
/////////////////////////////////////////////////////////////////////////////////
@init  
  IMAGE_LOGO = 0;
  IMAGE_BACKGROUND = 1;
  IMAGE_AVATAR = 2;
  IMAGE_UPPER_UI = 3;
  IMAGE_COPY = 4;
  // Print a log message
  function log_print(str) (
    //check overflow & shift
    #str = sprintf(#str, "> %s", str);
    (strcmp(mem_log_line[0], #str) != 0) ? ( 
      b = LOG_MAX_MESSAGE_COUNT - 1;
      loop(LOG_MAX_MESSAGE_COUNT - 1,
        strcpy(mem_log_line[b], mem_log_line[b - 1]);
        mem_log_line_counts[b] = mem_log_line_counts[b - 1];
        b -= 1;
      );   
      strcpy(mem_log_line[0], #str);
      mem_log_line_counts[0] = 0;            
    ) : (      
      mem_log_line_counts[0] += 1;
    );     
    log_redraw = 2;
  );  
  
  // Get new local CC identifier
  function assign_cc() (
    ccid += 1;
    ccid - 1;
  );
  
  // Assign CC to slider
  function init_cc(id) (
    i = assign_cc();
    cc[i] = id;
    mem_cc_slider[i] = slider_counter + 5;
    mem_cc_slider_old[i] = slider_counter + 5;
    mem_cc_slider_automateid[i] = i + 4;
    slider_counter += 1;
    i;
  );
  
  // Invalidate all slider states, not including PC
  function invalidate_cc_sliders() ( 
    c = 1;
    loop(CC_COUNT - 2, 
      mem_cc_slider_old[c] = -1;
      c += 1;
    ); 
  );
  
  // Invalidate all slider states
  function invalidate_sliders() (
    d = 0;
    loop(CC_COUNT - 1, 
      mem_cc_slider_old[d] = -1;
      d += 1;
    ); 
  );
  
  // Add a slider spacing ( slider_automate id bug hack)
  function slider_spacing() (
    slider_counter += 1;
  );
  
  // Get slider ID
  function get_slider(id) (
    slider(mem_cc_slider[id]);
  );    
  
  // Get slider automation ID (Reaper bug, automation IDs != slider IDs if spacings exist)
  function get_slider_automate(id) (
    slider(mem_cc_slider_automateid[id]);
  );
  
  // Send CC/PC
  function send_cc(cc, val) (
    cc == -1 ? midisend(0, 0xc0 | (s_channel - 1), val) : midisend(0, 0xb0 | (s_channel - 1), cc, val);    
    mem_midi_event_indicator[MIDI_EVENT_OUT] = 1;
  );
  
  // Send CC if changed
  function send_updated_cc(ccid, val) (
    get_slider(ccid) != mem_cc_slider_old[ccid] ? send_cc(cc[ccid], val);
  );
  
  // Update slider based on CC ID and value
  function update_cc_param(ccid, val) (        
    get_slider(ccid) = val;  
    slider_automate(get_slider_automate(ccid));        
  );
  
  // Is CC switch?
  function is_switch(cc) (
    (cc == vco2_octave_cc || cc == vco1_wave_cc || cc == vco2_wave_cc || cc == vco_mode_cc ||cc ==  lfo_wave_cc || cc == lfo_mode_cc || cc == lfo_target_cc || cc == eg_type_cc || cc == eg_target_cc);
  ); 
  
  // Is CC a centered knob?
  function is_centered_knob(cc) (
    (cc == vco2_pitch_cc || cc == lfo_intensity_cc || cc == eg_intensity_cc);
  ); 
  
  // Send PC to device (if changed)
  function send_pc_to_device() (
    send_updated_cc(program_cc, s_program - 1); 
  );  

  // Send CC to device (if changed, not including PC)
  function send_cc_to_device() (               
    f = 1;
    loop(CC_COUNT - 1,      
      is_switch(f) ? (
        f == vco2_octave_cc ? (
          send_updated_cc(f, min((get_slider(f) + 1) * 42, 127));   
        ) : (
          send_updated_cc(f, min(get_slider(f) * 64, 127));  
        )
      ) : (           
        (is_centered_knob(f)) ? (   
          send_updated_cc(f, get_slider(f) + 64);                                                          
        ) : (
          send_updated_cc(f, get_slider(f));                                            
        )
      );        
      f += 1;
    );
  );
  
  // Send PC and send a program dump request, optionally update sliders when answer is received, optionally send request again when answer is received (seems to be sometimes necessary)
  function update_program(id, update_sliders, send_twice) (  
    send_pc_to_device();
    (update_sliders) ? (
      midisend_str(0, "\xf0\x7E\x7F\x06\x01\xf7"); 
      program_request_id = id;
      program_request_update_sliders = update_sliders;
      program_request_send_twice = send_twice;
    );
  );
  
  #VERSION = "1.0";
  #CREDITS = sprintf(#CREDITS, "MonoCtrl v%s\n=============\nWritten by Jan Vorisek in 2019.\nThis took more work than it should have.\n\njan@blokatt.net | blokatt.net | @blokatt", #VERSION);
  
          
  ext_noinit = 1.0;

  CC_COUNT = 23;
  cc = 0;
  
  // Memory offsets
  mem_cc_slider = 100;              // Slider values
  mem_cc_slider_old = 200;          // Old slider values
  mem_cc_slider_automateid = 300;   // Slider automation IDs 
  mem_log_line = 400;               // Log string pointers
  mem_log_line_counts = 500;        // Log same string counters
  mem_button_clicked = 600;         // Button clicked status 
  mem_program_request_param = 700;  // Program request parameters (two rightmost bits)
  mem_midi_event_indicator = 900;   // MIDI I/O indicators
  mem_log_line_str = 1000;          // Log strings
  //////////////////
  
  // Testing for successful program request
  program_request = 0; 
  program_request_timer = 0;
  //
  button_redraw = 5;

  log_redraw = 1;
  LOG_MAX_MESSAGE_COUNT = 99;
  LOG_HORIZONTAL_OFFSET = 200;
  
  // Init log line memory offsets 
  a = 0; 
  loop(LOG_MAX_MESSAGE_COUNT,
    mem_log_line[a] = mem_log_line_str + a;
    a += 1;
  );
  //

  send_cc_timer = 0;
  send_cc_delay = 0;
  
  slider_counter = 0;
  last_play_state = 0;

  gfx_w_old = gfx_w;
  gfx_h_old = gfx_w;
  
  //
  fade_alpha = 1;
  GLOBAL_STATE_MAIN = 0;
  GLOBAL_STATE_SECRET = 1;
  global_state = GLOBAL_STATE_MAIN;
  //
  
  CURSOR_NORMAL = 32512;
  CURSOR_HAND = 32649;
  
  BUTTON_RANDOMISE = 0;
  BUTTON_MUTATE = 1;
  BUTTON_SEND = 2;
  BUTTON_GET = 3;
  
  BACKGROUND_PATTERN_HEIGHT = 280;
  AVATAR_HEIGHT = 444;
  
  MIDI_EVENT_OUT = 0;  
  MIDI_EVENT_IN = 1;   
  
  program_change_delay = 0;
  program_change_waiting = 0;
  
  /*
  Init order must be same as slider order!
  */     
  ccid = 0;
  
  program_cc = init_cc(-1);
  slider_spacing();
 
  vco1_wave_cc = init_cc(50);      
  vco1_shape_cc = init_cc(36);
  
  slider_spacing();
 
  vco2_wave_cc = init_cc(51);    
  vco2_shape_cc = init_cc(37);
  vco2_pitch_cc = init_cc(35);
  vco2_octave_cc = init_cc(49);
  
  slider_spacing();
  
  vco_mode_cc = init_cc(60);
  
  slider_spacing();
  
  vco1_level_cc = init_cc(39);
  vco2_level_cc = init_cc(40);
  
  slider_spacing();
  
  cutoff_cc = init_cc(43);
  resonance_cc = init_cc(44);
  
  slider_spacing();
  
  lfo_wave_cc = init_cc(58);
  lfo_mode_cc = init_cc(59);  
  lfo_rate_cc = init_cc(24);
  lfo_intensity_cc = init_cc(26);  
  lfo_target_cc = init_cc(56);
  
  slider_spacing();
  
  eg_type_cc = init_cc(61);
  eg_attack_cc = init_cc(16);  
  eg_decay_cc = init_cc(17);
  eg_intensity_cc = init_cc(25);  
  eg_target_cc = init_cc(62);  
  
  slider_spacing();
  drive_cc = init_cc(28);  
  log_print("====================================================");   
  log_print("Set input to:");
  log_print("MIDI -> Monologue KBD/KNOB -> All channels");
  log_print("Set hardware MIDI output to:");
  log_print("Monologue SOUND (low precision)");
  log_print("Enable input monitoring and arm this track.");   
  log_print("====================================================");     
    
  s_program_old = s_program;
  update_program(s_program - 1, 0, 1);
  

/////////////////////////////////////////////////////////////////////////////////
//////////////////// - A RATHER LARGE SECTION SEPARATOR. - //////////////////////
/////////////////////////////////////////////////////////////////////////////////
@block  
  function buf_sub_str(bfr, a, b) (
    #str = "";
    e = 0;
    loop(b, 
      sprintf(#str, "%s%c", #str,bfr[a + e]);
      e += 1;
    );    
    #str;      
  );
  
  function on_playback_start() (
    send_pc_to_device();
    invalidate_cc_sliders(); 
    send_cc_to_device();
    log_print("Playing...");
    (s_send_pc_on_init == 0) ? update_program(s_program - 1, 1, 1);
  );
  
  function rand_int(x) (
    min(floor(rand(x + 1)), x);  
  );
  
  ///////// PROCESS INCOMING MIDI /////////
  buf = 10000;
  maxlen = 65536;  
  while ((recvlen = midirecv_buf(offset, buf, maxlen)) > 0) (
    event_type = buf[0] >> 4;
    channel = buf[0] & 15;        
        
    //Program request answer
    (recvlen == 15 && event_type == 0xf) ? (    
      id = program_request_id;
      update_sliders = program_request_update_sliders;
      send_twice = program_request_send_twice;
      send = 1000;
      send[0] = 0xf0;
      send[1] = 0x42;
      send[2] = 0x30 | (s_channel - 1);
      send[3] = 0x00;
      send[4] = 0x01;
      send[5] = 0x44;
      send[6] = 0x1c;
      send[7] = s_program - 1;
      send[8] = 0x00;
      send[9] = 0xf7;     
      midisend_buf(10,send,10);               
      mem_program_request_param[id] = (!update_sliders << 1) | send_twice;
      block_slider_update = !update_sliders;
      program_request = update_sliders;
      mem_midi_event_indicator[MIDI_EVENT_OUT] = 1;
    ) : (
    //Program Dump
    (recvlen >= 518 && event_type == 0xf && (buf[2] & 15) == s_channel - 1) ? (                               
      offset = 6;
      block_slider_update = 0;        
      program = -1;      
      (buf[offset] == 0x4c) ? (
        program = buf[offset + 1];
        s_program = program + 1;
        block_slider_update = mem_program_request_param[buf[offset + 1]] >> 1;
        offset += 4;
      ) : (
        offset += 2;
      );     
      
      i = 0;
  
      #temp = buf_sub_str(buf, offset, 4);
      (strcmp(#temp,  "PROG") == 0 && !block_slider_update) ? (                      
        program_request = 0;
        program_request_timer = 0;
        //sprintf(#temp,"%f",rand(5));
        offset += 4;
        
        #temp = "";
        
        last_non_w = 0;
        h = 0;
        valid = 0;
        loop(14,
          (buf[offset + h] != 0 && h != 11)? (
            sprintf(#temp, "%s%c", #temp, buf[offset + h]);
            (buf[offset + h] != ' ') ? last_non_w = h;
            valid += 1;
          ); 
          h += 1;
        );             
        
        strcpy(#temp2, #temp);  
        #temp = strcpy_substr(#temp, #temp2, 0, last_non_w);
           
        ///// vco1 level
        offset += 11;        
        value = ((buf[offset] & 64) << 3);
        value = value | ((buf[offset + 7] & 127) << 2);
        value = value | (buf[offset + 22] & 3);
        update_cc_param(vco1_level_cc, value >> 3);
                  
        /////vco2 shape
        value = ((buf[offset] & 32) << 4);
        value = value | ((buf[offset + 6] & 127) << 2);
        value = value | ((buf[offset + 20] & 12) >> 2);
        update_cc_param(vco2_shape_cc, value >> 3);  
                  
        ///// vco2 pitch
        value = ((buf[offset] & 16) << 5);
        value = value | ((buf[offset + 5] & 127) << 2);
        value = value | (buf[offset + 20] & 3);  
        update_cc_param(vco2_pitch_cc, value >> 3 - 64);      
        
        ///// vco1 shape
        value = ((buf[offset] & 8) << 6);
        value = value | ((buf[offset + 4] & 127) << 2);
        value = value | ((buf[offset + 19] & 12) >> 2);        
        update_cc_param(vco1_shape_cc, value >> 3);
        
        ///// lfo rate
        offset += 8;        
        value = (buf[offset] & 64) << 3;
        value = value | ((buf[offset + 7] & 127) << 2);
        value = value | ((buf[offset + 17] & 12) >> 2);    
        update_cc_param(lfo_rate_cc, value >> 3);    
        
        ///// eg intensity
        value = (buf[offset] & 32) << 4;
        value = value | ((buf[offset + 6] & 127) << 2);
        value = value | (buf[offset + 17] & 3);
        update_cc_param(eg_intensity_cc, (value >> 3) - 64);          
        
        ///// eg decay
        value = (buf[offset] & 16) << 5;
        value = value | ((buf[offset + 5] & 127) << 2);
        value = value | ((buf[offset + 15] & 48) >> 4);
        update_cc_param(eg_decay_cc, value >> 3);
                  
        ///// eg attack
        value = (buf[offset] & 8) << 6;
        value = value | ((buf[offset + 4] & 127) << 2);
        value = value | ((buf[offset + 15] & 12) >> 2);      
        update_cc_param(eg_attack_cc, value >> 3);  
        
        ///// filter resonance
        value = (buf[offset] & 4) << 7;
        value = value | ((buf[offset + 3] & 127) << 2);
        value = value | ((buf[offset + 8] & 32) >> 4);
        value = value | ((buf[offset + 14] & 64) >> 6);    
        update_cc_param(resonance_cc, value >> 3);   
        
        ///// filter cutoff
        value = (buf[offset] & 2) << 8;
        value = value | ((buf[offset + 2] & 127) << 2);
        value = value | ((buf[offset + 14] & 48) >> 4);
        update_cc_param(cutoff_cc, value >> 3);          
        
        ///// vco2 level
        value = ((buf[offset] & 1) << 9);
        value = value | ((buf[offset + 1] & 127) << 2);
        value = value | (buf[offset + 14] & 12) >> 2;
        update_cc_param(vco2_level_cc, value >> 3);          
        
        ///// eg target
        offset += 8;        
        value = (buf[offset] & 64) >> 5;
        value = value | ((buf[offset + 7] & 64) >> 6);
        update_cc_param(eg_target_cc, value);
        
        ///// vco2 wave
        value = ((buf[offset] & 8) >> 2);
        value = value | ((buf[offset + 4] & 64) >> 6);
        update_cc_param(vco2_wave_cc, value);
        
        ///// vco1 wave
        value = ((buf[offset] & 4) >> 1);
        value = value | ((buf[offset + 3] & 64) >> 6);
        update_cc_param(vco1_wave_cc, value);
        
        ///// drive
        value = ((buf[offset] & 2) << 8);
        value = value | ((buf[offset + 2] & 127) << 2);
        value = value | ((buf[offset + 8] & 1) << 1);
        value = value | ((buf[offset + 9] & 64) >> 6);
        update_cc_param(drive_cc, value >> 3);
        
        ///// lfo intensity
        value = (buf[offset] & 1) << 9;
        value = value | ((buf[offset + 1] & 127) << 2);
        value = value | ((buf[offset + 9] & 48) >> 4);
        update_cc_param(lfo_intensity_cc, (value >> 3) - 64);
        
        ///// vco2 octave
        offset += 4;
        value = (buf[offset] & 48) >> 4;
        update_cc_param(vco2_octave_cc, value - 1);
        
        ///// ring/sync
        offset += 1;
        value = (buf[offset] & 3);
        update_cc_param(vco_mode_cc, value);
        
        ///// eg type
        offset += 2;        
        value = (buf[offset] & 3);     
        update_cc_param(eg_type_cc, value );
        
        ///// lfo target    
        offset += 3;        
        value = (buf[offset] & 48) >> 4;
        update_cc_param(lfo_target_cc, value);
        
        ///// lfo mode
        value = (buf[offset] & 12) >> 2;
        update_cc_param(lfo_mode_cc, value);
        
        ///// lfo wave
        value = (buf[offset] & 3);
        update_cc_param(lfo_wave_cc, value);
        (program != -1) ? (
          (mem_program_request_param[program] & 1) ?  echo_program_request = 5;
          // this is how i fix timing issues
          s_program = program + 1;
          s_program_old = s_program;   
        );
        (program == -1 || (program >= 0 && !mem_program_request_param[program] & 1)) ? ( 
          (program != -1) ? (
            log_print(sprintf(#, "RECV: Program %d: '%s'", s_program, #temp)); 
          ) : (
            log_print(sprintf(#, "RECV: Program: '%s'", #temp)); 
          );
          #program_name = "";
          strcpy(#program_name, #temp);
        ); 
        mem_midi_event_indicator[MIDI_EVENT_IN] = 1;  
      );      
      
      /*
        The synth won't accept CC for a while after
        transmitting program data, so we wait a bit
        before sending all the sliders back to it.
        (precision consistency, non-updated sliders, etc...)  
      */
      send_cc_delay = 1;
      send_cc_timer = srate * .1;
  
      block_slider_update = 0;    
      i = 1;
      loop(CC_COUNT - 1, 
        mem_cc_slider_old[i] = get_slider(i);
        i += 1;
      );                 
    ) : ( //CC
    (channel == s_channel - 1) ? (
      (event_type == 0xb) ? (
        val =  buf[2];
        g = 1;
        loop(CC_COUNT - 1, 
          buf[1] == cc[g] ? (
            is_switch(g) ? (
              g == vco2_octave_cc ? (
                get_slider(g) = floor((val) / 42) - 1;   
              ) : (
                get_slider(g) = floor((val + 1) / 64);   
              )
            ) : (           
              (is_centered_knob(g)) ? (   
                get_slider(g) = val - 64;                                                            
              ) : (
                get_slider(g) = val;                                            
              )
            );
            slider_automate(get_slider_automate(g));        
            mem_midi_event_indicator[MIDI_EVENT_IN] = 1;  
          );
          g += 1;
      );            
    ) : ( // Program change
    (event_type == 0xc) ? (            
      get_slider(program_cc) = buf[1] + 1;  
      slider_automate(get_slider(program_cc));                   
      mem_midi_event_indicator[MIDI_EVENT_IN] = 1;
    ) : ( // Passthrough, clock is blocked by default                 
    (buf[0] != 0xF8 && (s_block_midi_passthrough == 0) || (s_block_midi_passthrough == 1 && play_state  == 1)) ? (
      midisend_buf(offset,buf,recvlen);               
      mem_midi_event_indicator[MIDI_EVENT_IN] = 1;
      mem_midi_event_indicator[MIDI_EVENT_OUT] = 1;
    );
    );
    );
    );            
    ); 
    );
  );    
  send_cc_to_device();  // Send slider changes
  /////////////////////////////////////////
  
  // Buttons
  (mem_button_clicked[BUTTON_GET]) ? update_program(s_program -  1, 1, 1);
  (mem_button_clicked[BUTTON_SEND]) ? update_program(s_program - 1, 0, 1);    
  (mem_button_clicked[BUTTON_MUTATE]) ? (
    update_cc_param(vco1_wave_cc, min(2, max(0, s_vco1_wave + rand_int(2) - 1)));
    update_cc_param(vco1_shape_cc, min(127, max(0, s_vco1_shape + rand_int(10) - 5)));          
    update_cc_param(vco2_wave_cc, min(2, max(0, s_vco2_wave + rand_int(2) - 1)));
    update_cc_param(vco2_shape_cc,  min(127, max(0, s_vco2_shape + rand_int(10) - 5)));          
    update_cc_param(vco2_pitch_cc, min(63, max(-64, s_vco2_pitch + rand_int(10) - 5)));  
    update_cc_param(vco2_octave_cc, min(2, max(-1, s_vco2_octave + rand_int(2) - 1)));
    update_cc_param(vco_mode_cc, min(2, max(0, s_vco_mode + rand_int(2) - 1)));
    update_cc_param(vco1_level_cc, min(127, max(0, s_vco1_level + rand_int(10) - 5)));          
    update_cc_param(vco2_level_cc, min(127, max(0, s_vco2_level + rand_int(10) - 5)));          
    update_cc_param(cutoff_cc, min(127, max(0, s_filter_cutoff + rand_int(10) - 5)));          
    update_cc_param(resonance_cc, min(127, max(0, s_filter_resonance + rand_int(10) - 5)));         
    update_cc_param(lfo_wave_cc, min(2, max(0, s_lfo_wave + rand_int(2) - 1)));
    update_cc_param(lfo_mode_cc, min(2, max(0, s_lfo_mode + rand_int(2) - 1)));
    update_cc_param(lfo_rate_cc, min(127, max(0, s_lfo_rate + rand_int(10) - 5)));    
    update_cc_param(lfo_intensity_cc, min(63, max(-64, s_lfo_intensity + rand_int(10) - 5)));  
    update_cc_param(lfo_target_cc, min(2, max(0, s_lfo_target + rand_int(2) - 1)));
    update_cc_param(eg_type_cc ,min(2, max(0, s_eg_type + rand_int(2) - 1)));          
    update_cc_param(eg_attack_cc, min(127, max(0, s_eg_attack + rand_int(6) - 3)));    
    update_cc_param(eg_decay_cc, min(127, max(0, s_eg_decay + rand_int(10) - 5)));    
    update_cc_param(eg_intensity_cc, min(63, max(-64, s_eg_intensity + rand_int(10) - 5)));  
    update_cc_param(eg_target_cc, min(2, max(0, s_eg_target + rand_int(2) - 1)));
    update_cc_param(drive_cc, min(127, max(0, s_drive + rand_int(10) - 5)));         
    log_print("Sliders mutated.");
    invalidate_cc_sliders();       
    send_cc_to_device();
  );  
  (mem_button_clicked[BUTTON_RANDOMISE]) ? (
    update_cc_param(vco1_wave_cc, rand_int(2));
    update_cc_param(vco1_shape_cc, rand_int(0x7f));        
    update_cc_param(vco2_wave_cc, rand_int(2));
    update_cc_param(vco2_shape_cc, rand_int(0x7f));
    update_cc_param(vco2_pitch_cc, -64 + rand_int(0x7f));
    update_cc_param(vco2_octave_cc, -1 + rand_int(3));        
    update_cc_param(vco_mode_cc, rand_int(2));        
    update_cc_param(vco1_level_cc, rand_int(0x7f));
    update_cc_param(vco2_level_cc, rand_int(0x7f));        
    update_cc_param(cutoff_cc, rand_int(0x7f));
    update_cc_param(resonance_cc, rand_int(0x7f));        
    update_cc_param(lfo_wave_cc, rand_int(2));
    update_cc_param(lfo_mode_cc, rand_int(2));
    update_cc_param(lfo_rate_cc, rand_int(127));
    update_cc_param(lfo_intensity_cc, -64 + rand_int(0x7f));
    update_cc_param(lfo_target_cc,  rand_int(2));        
    update_cc_param(eg_type_cc, rand_int(2));
    update_cc_param(eg_attack_cc,  floor(min(pow(rand(1), 8) * 0x7f, 0x7f)));
    update_cc_param(eg_decay_cc, floor(min(0x7f - pow(rand(1), 5) * 0x7f, 0x7f)));
    update_cc_param(eg_intensity_cc, -64 + rand_int(0x7f));
    update_cc_param(eg_target_cc, rand_int(2));
    update_cc_param(drive_cc, rand_int(0x7f));
    log_print("Sliders randomised.");
    invalidate_cc_sliders();       
    send_cc_to_device();
  );    
  
  l = 0;
  loop(10,  
    mem_button_clicked[l] = 0;
    l += 1;
  );
  
  /////
  
  
  /*  
  Hack to detect local preset change:
  Don't auto-update program if any knobs have been moved during this block.  
  */
  cc_changed = 0;
  k = 1;
  loop(CC_COUNT - 1,
    (get_slider(k) != mem_cc_slider_old[k]) ? cc_changed = 1;
    k += 1;
  );
              
    
  // Delayed CC sending (synth might block incoming CC when loading a preset)
  (send_cc_delay) ? (
    (!send_cc_timer) ? (
      invalidate_cc_sliders(); 
      send_cc_to_device();  
      send_cc_delay = 0;
    );
    send_cc_timer = max(0, send_cc_timer - samplesblock);
  );   
          
  // Playback start detection
  (play_state && !last_play_state) ? (
    on_playback_start();
  );
  last_play_state = play_state;
  
  // Repeat a program request (seems to be necessary when program number is >~64 for some reason)  
  (echo_program_request > 0) ? (
    (echo_program_request == 1) ? (
      update_program(s_program - 1, !(mem_program_request_param[s_program - 1] >> 1), 0);      
    );
    echo_program_request -= 1;
  );
  
  // Auto-send program request
  (s_program != s_program_old) ? (  
    program_change_delay = (srate * .1) * (s_send_pc_on_init != 2);
    program_change_waiting = 1;    
    program_change_params = !cc_changed && (s_send_pc_on_init != 2);
  );  
  (program_change_waiting) ? (
    program_change_delay = max(0, program_change_delay - samplesblock);
    (program_change_delay == 0) ? (
      
      update_program(s_program - 1, program_change_params, 1);                      
      program_change_waiting = 0;
    );
  );
  
     
  s_program_old = s_program;
  
  // Error message timer
  (program_request) ? (
    program_request_timer += samplesblock;
    (program_request_timer > srate) ? (
      log_print("ERROR: PROGRAM REQUEST FAILED! Make sure this track is armed and MIDI input is enabled on all channels. Enable Tx/Rx MIDI in the global settings of your synth.");
      program_request_timer = 0;
      program_request = 0;
    );
  );    
  
  // Old slider values    
  m = 1;
  loop(CC_COUNT - 1, 
    mem_cc_slider_old[m] = get_slider(m);
    m += 1;
  );

/////////////////////////////////////////////////////////////////////////////////
//////////////////// - A RATHER LARGE SECTION SEPARATOR. - //////////////////////
/////////////////////////////////////////////////////////////////////////////////
@gfx 560, 110
  function draw_string_outlined(str, flags, right, bottom) (
    old_gfx_x = gfx_x;
    old_gfx_y = gfx_y;
    
    // back
    gfx_set(.48, .215, 1, 1);
    gfx_x = old_gfx_x - 1;            
    gfx_drawstr(str, flags, right, bottom);
    gfx_x = old_gfx_x;
    gfx_y = old_gfx_y + 1;
    gfx_drawstr(char);
    gfx_set(.58, .215, 1, .5);              
    gfx_x = old_gfx_x + 1;            
    gfx_y = old_gfx_y;
    gfx_drawstr(str, flags, right, bottom);
    gfx_x = old_gfx_x;
    gfx_y = old_gfx_y - 1;                        
    gfx_drawstr(str, flags, right, bottom);
    gfx_x = old_gfx_x;
    gfx_y = old_gfx_y;
    
    // front
    gfx_mode = 1;
    gfx_set(.9, .9, 1., .9);
    gfx_drawstr(str, flags, right, bottom);
    gfx_set(1, 1, 1, 1);
    gfx_mode = 0;
  );
  
  function draw_button(x, y, str, id) (
    gfx_x = x;
    gfx_y = y;
    gfx_measurestr(str, w, h);
    gfx_set(.25, .25, .25);
    gfx_set(.1, .1, .1);
    x0 = gfx_x - w - 5;
    y0 = gfx_y - h / 2 - 2;
    w += 10;
    h += 3;
    
    (!(mouse_cap & 1)) ? (
      released = 1;
    );       
    
    gfx_rect(x0, y0, w, h, 1); 
    
    gfx_gradrect(x0, y0, w, h, .6, .3, 1, 1, 0, 0, 0, 0, -.027, -.02, -.03, 0);
    
    gfx_mode = 1;
    gfx_set(1., 0, 0, -1, 1);
    gfx_rect(x0 + 1, y0 + 1, w  - 2, h - 2, 0); 
    gfx_mode = 0;
    gfx_set(.8, .7, 1);
    gfx_rect(x0, y0, w, h, 0); 
    gfx_mode = 0;
    gfx_set(.9, 1., 1);
    
    (mouse_x >= x0 && mouse_y >= y0 && mouse_x <= x0 + w && mouse_y <= y0 + h) ? (      
      gfx_mode = 1;
      gfx_gradrect(x0, y0, w, h, .4, .1, .8, .75, 0, 0, 0, 0, -.03, -.03, -.03, 0);
      gfx_mode = 0;
      gfx_setcursor(CURSOR_HAND);
      gfx_set(1, 1, 1);
      (mouse_cap & 1) ? (
        gfx_y += 1;
        gfx_mode = 1;
        gfx_gradrect(x0, y0, w, h, .6, .1, .2, -.25, 0, 0, 0, 0, -.03, -.03, -.03, 0);
        gfx_mode = 0;
        (mem_button_clicked[id] == 0 && released) ? (
          mem_button_clicked[id] = 1;      
          released = 0;
        );
      );        
    );        
    gfx_drawstr(str, 42|256, gfx_x, gfx_y + 5);
  );
  
  function draw_event_indicator(x, y, id) ( 
    gfx_set(.03, 0, .22);
    gfx_circle(x, y, 3, 1, 1);
    gfx_set(.15, .1, .6);
    gfx_circle(x, y, 3, 0, 1);     

    gfx_mode = 1;
    mem_midi_event_indicator[id] = max(0, mem_midi_event_indicator[id] - .2);
    gfx_set(.88, .315, 1, mem_midi_event_indicator[id]);      
    gfx_circle(x, y, 1 + mem_midi_event_indicator[id], 1, 1);
    gfx_mode = 0;
 
    gfx_set(.9, .8, 1);
    gfx_circle(x, y, 4, 0, 1);    
     
    side = 1 - 2 * id;
    gfx_set(.5, .4, 1, .5);
    gfx_triangle(x - 15, y + 3 * side - side, x - 12, y - 3 * side + side, x - 9, y + 3 * side - side);
    gfx_set(.5, .4, 1);
    gfx_triangle(x - 15, y + 3 * side, x - 12, y - 3 * side, x - 9, y + 3 * side);
    gfx_set(1, 1, 1, 1);
    gfx_triangle(x - 14, y + 2 * side, x - 12, y - 2 * side, x - 10, y + 2 * side);
  );
  
  gfx_setfont(1, "Courier New", 13);
  gfx_setcursor(CURSOR_NORMAL);
  gfx_setimgdim(IMAGE_COPY, gfx_w, gfx_h); // screen copy
  gfx_setimgdim(IMAGE_UPPER_UI, gfx_w, gfx_h); // log/buttons
    
  gfx_set(1, 1, 1, 1);
  // Secret
  (global_state == GLOBAL_STATE_MAIN && fade_alpha < .01) ? (
    (mouse_x <= 35 && mouse_y >= gfx_h - 16) ? (      
      gfx_setcursor(CURSOR_HAND);
      (mouse_cap & 1) ? (          
        global_state = GLOBAL_STATE_SECRET;
        credits_characters = 0;
        credits_mouse_released = 0;
        fade_alpha = .25;
        gfx_dest = IMAGE_COPY;   
        gfx_blit(-1, 1, 0);  
        gfx_dest = -1;  
        gfx_x = 0;
        gfx_y = 0;
        gfx_blit(IMAGE_COPY, 1, 0);  
        gfx_clear = -1; 
      );
    );
  );
    
  (global_state == GLOBAL_STATE_MAIN) ? (
  
    // Render background
    repeats = ceil((gfx_h + 20) / BACKGROUND_PATTERN_HEIGHT);
    i = 0;
    gfx_x = 0;
    off = (time_precise() * 20) % 20;
    loop(repeats,   
      gfx_y = floor(BACKGROUND_PATTERN_HEIGHT * i - off);
      gfx_blit(IMAGE_BACKGROUND, 1, 0);
      i += 1;
    );
  
    gfx_clear = 0;
      
    // Redraw checking
    (mouse_y <= 25 && mouse_y >= 0) ? (
      button_redraw = 5;
    );    
    (gfx_w_old != gfx_w || gfx_h_old != gfx_h) ? (      
      log_redraw = 2;
      console_redraw = 5;
    );
    
            
    scale = 1;
            
    // Message log rendering
    (log_redraw) ? (
      gfx_x = 0;
      gfx_y = 0;
     
      gfx_dest = IMAGE_UPPER_UI;   
      gfx_muladdrect(0, 0, gfx_w, gfx_h, 1, 1, 1, 0);     
      //gfx_clear = -1;
     
      i = 0;
      gfx_y = gfx_h - 20;    
      
      max_len = (gfx_w - LOG_HORIZONTAL_OFFSET - 20) / 6;    
      line_breaks = 0;        
      log_screen_max_message_count = min(LOG_MAX_MESSAGE_COUNT, floor(gfx_h / 10) - 3);  
      loop(log_screen_max_message_count,
        (line_breaks < log_screen_max_message_count) ? (         
          #line = "";
          strcpy(#line, mem_log_line[i]);
          (mem_log_line_counts[i] > 0) ? sprintf(#line, "%s (%d)", #line, mem_log_line_counts[i]); 
          
          gfx_set(1, 1, 1);
          message_is_error = 0;
          (match("> ERROR:*", #line)) ? message_is_error = 1;
          
          len = strlen(#line);      
          off = 0;
          premature_break = 0;
          line_off = 0;
          local_line_breaks = 0;
          #broken_line = "";
         
          ///// Assemble broken up line, prevent mid-word breaks if possible
          loop(len,
          
            // Analyse the current word
            (str_getchar(#line, off) != ' ') ? (
              (!read_word) ? (
                j = 0;
                stop_reading = 0;
                while (!stop_reading && j <= len)(
                  ((line_off + j) > max_len) ? (                  
                    premature_break = 1;                                      
                    stop_reading = 1;              
                  );
                  //
                  (j > 15 || str_getchar(#line, off + j) == ' ') ? stop_reading = 1;
                  j += 1;              
                );
                read_word = 1;
              );
            ) : (
              read_word = 0;                        
            );
            
            // Place a line break
            ((line_off > max_len || premature_break)) ? (              
              line_off = 0;
              local_line_breaks += 1;
              premature_break = 0;
              sprintf(#broken_line, "%s\n", #broken_line);
            ); 
                        
            sprintf(#broken_line, "%s%c", #broken_line, str_getchar(#line, off));
            off += 1;
            line_off += 1;
          );
          /////////////////        
          message_vertical_offset = local_line_breaks * 10;
          
          ///// Print char by char
          gfx_x = LOG_HORIZONTAL_OFFSET;        
          gfx_y -= message_vertical_offset;
          
          off = 0;
          loop(strlen(#broken_line), 
            char = str_getchar(#broken_line, off);
            (char == '\n') ? (
              gfx_x = LOG_HORIZONTAL_OFFSET;
              gfx_y += 10;
            ) : (
              old_gfx_x = gfx_x;
              old_gfx_y = gfx_y;            
              //
              gfx_set(.48, .215, 1, 1);
              (message_is_error) ? gfx_set(.48, .3, .8, .5);
              gfx_x = old_gfx_x - 1;            
              gfx_drawchar(char);
              //
              gfx_x = old_gfx_x;
              gfx_y = old_gfx_y + 1;
              gfx_drawchar(char);
              //
              
              //
              gfx_set(.58, .215, 1, .5);              
              (message_is_error) ? gfx_set(.58, .3, .8, .25);
              gfx_x = old_gfx_x + 1;            
              gfx_y = old_gfx_y;
              gfx_drawchar(char);
              gfx_x = old_gfx_x;
              gfx_y = old_gfx_y - 1;                        
              gfx_drawchar(char);
              //
              
              gfx_x = old_gfx_x;
              gfx_y = old_gfx_y;
              gfx_mode = 1;
              gfx_set(.9, .9, 1., .9);
              (message_is_error) ? gfx_set(1, .8, .86, 1.25);
              gfx_drawchar(char);
              gfx_mode = 0;
            );
            off += 1;
          );
          gfx_y -= message_vertical_offset + 10;
          /////////////////   
          i += 1;
          line_breaks += 1;
        );        
      );
      gfx_set(0.0, 0.0, 0.0);                    
      gfx_rect(LOG_HORIZONTAL_OFFSET, 0, gfx_w - LOG_HORIZONTAL_OFFSET, 25);
      gfx_gradrect(LOG_HORIZONTAL_OFFSET, 25, gfx_w - LOG_HORIZONTAL_OFFSET, 6, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -.166);
      gfx_set(1.0, 1.0, 1.0);     
      
      gfx_set(.1, 0., .25, 1., 0.);      
      gfx_rect(LOG_HORIZONTAL_OFFSET, 8, gfx_w, 4);
      gfx_rect(LOG_HORIZONTAL_OFFSET, 15, gfx_w, 2);
      gfx_set(1., 1., 1., 1., 0.);           
      
      gfx_dest = -1;
    );
    
    gfx_set(1., 1., 1., 1.);

    // Buttons
    (button_redraw || log_redraw) ? (
      gfx_dest = IMAGE_UPPER_UI;
      x_offset = gfx_w - 10;
      draw_button(x_offset, 13, "MUTATE", BUTTON_MUTATE);
      x_offset -= w + 5;
      draw_button(x_offset, 13, "RANDOMISE", BUTTON_RANDOMISE);
      x_offset -= w + 5;
      draw_button(x_offset, 13, "SEND", BUTTON_SEND);
      x_offset -= w + 5;
      draw_button(x_offset, 13, "GET", BUTTON_GET);
      gfx_dest = -1;      
    );        
    
    // Decrese redraw checkers
    button_redraw = max(0, button_redraw - 1);
    log_redraw = max(0, log_redraw - 1);
    
    // Version number
    gfx_x = 8;
    gfx_y = gfx_h - 4;    
    
    draw_string_outlined(sprintf(#, "v%s", #VERSION), 8|256, gfx_x, gfx_y);
          
    gfx_set(.1, 0., .25, 1., 1.);      
    gfx_rect(0, 8, gfx_w, 4);
    gfx_rect(0, 15, gfx_w, 2);
    gfx_rect(8, 0, 4, gfx_h);
    gfx_rect(15, 0, 2, gfx_h);
    gfx_set(1., 1., 1., 1., 0.);         

    // Draw log & buttons
    gfx_x = 0;
    gfx_y = 0;        
    gfx_set(1, 1, 1, 1);    
    gfx_blit(IMAGE_UPPER_UI, 1, 0);  
    
    // Draw current program name
    /*
    (#program_name != "") ? ( 
      gfx_x = 6;
      gfx_y = 5;
      gfx_drawstr(#program_name);
    );
    */
    
    // MIDI indicators
    (x_offset > LOG_HORIZONTAL_OFFSET + 80) ? (
      draw_event_indicator(LOG_HORIZONTAL_OFFSET + 15, 12, MIDI_EVENT_IN); 
      draw_event_indicator(LOG_HORIZONTAL_OFFSET + 46, 12, MIDI_EVENT_OUT); 
    );        
    
    gfx_x = 0;
    gfx_y = 0;
    
    // (Orna)mental rectangle
    gfx_rect(1, 1, gfx_w - 1, gfx_h - 1,0);
  );
  
  // SPOILERS
  (global_state == GLOBAL_STATE_SECRET) ? (
    effect_time = time_precise();
    gfx_x = 0;
    gfx_y = -1;
    gfx_blit(-1, 1, sin(effect_time * .4) * .002); 
    loop(5, gfx_blurto(gfx_w, gfx_h));
    gfx_muladdrect(0, 0, gfx_w, gfx_h, .95 + cos(effect_time * .125) * .01, .8, .99 + sin(effect_time * .25) * .01);
    
    credits_length = strlen(#CREDITS);
    //
    avatar_scale = gfx_h / AVATAR_HEIGHT * 1;
    gfx_x = gfx_w - AVATAR_HEIGHT * avatar_scale;
    gfx_y = gfx_h - gfx_h * (credits_characters / credits_length) * .9;
    gfx_set(0., 0., 0., .1 + .3 * (1.0 - (credits_characters / credits_length)), 1.);    
    gfx_blit(IMAGE_AVATAR, avatar_scale, sin(effect_time * 1) * .02, -1);
    //
    
    gfx_set(.5, .7, .9, 1, 1);        
    gfx_x = gfx_w - 10;
    gfx_y = gfx_h * .25 + sin(effect_time * 2) * 3;
    credits_characters = min(credits_length, credits_characters + 1);
    draw_string_outlined(strcpy_substr(#,#CREDITS, 0, credits_characters), 2|256, gfx_x, gfx_y);
    gfx_set(1, 1, 1, 1);
    
    plasma_x = 0;
    plasma_y = 0;
    plasma_w = gfx_w / 10;
    plasma_h = gfx_h / 10;
    plasma_step_x = 1. / plasma_w;
    plasma_step_y = 1. / plasma_h;
    plasma_row = 1;
    loop(plasma_h + 1,     
      plasma_x = 0;
      loop(plasma_w + 1, 
        gfx_set(.8 + cos(effect_time * .05) * .18, .1, .4 + sin(effect_time * .1 + plasma_x * .5) * .1, -.11, 1);
        plasma_radius = (sin(effect_time * 5 + plasma_x * 30 + plasma_y * 2) * cos(plasma_y * 5 - effect_time * 5)) * .5 + .5;
        gfx_circle((plasma_x + plasma_step_x * .5 * plasma_row) * gfx_w + sin(effect_time + plasma_y + plasma_x) * 5, (plasma_y + plasma_step_y * .5) * gfx_h + cos(effect_time * 2 + plasma_y * 5) * 10, (1 + 5 * plasma_radius) * (plasma_y * .8), 1);
        plasma_x += plasma_step_x;        
      );
      plasma_row = !plasma_row;
      plasma_y += plasma_step_y;
    );
    gfx_mode = 0;    
    loop(250,     
      fire_x = rand(gfx_w);
      gfx_set(.8 + rand(.2), sin(effect_time + fire_x * .005) * .5 + .5, 1, rand(1));
      gfx_circle(fire_x, gfx_h - 2 + rand(5), rand(4), 1);    
    );
    gfx_setcursor(CURSOR_HAND);

    (mouse_cap & 1 && credits_mouse_released) ? (
      fade_alpha = 1;
      gfx_set(1, 1, 1, 1);
      log_redraw = 1;
      console_redraw = 1;
      global_state = GLOBAL_STATE_MAIN;        
    );

    (!(mouse_cap & 1)) ? credits_mouse_released = 1;
  );
  
  // LOGO
  logo_y_offset = (sin(time_precise() * 5) * 7) * (4. * (.25 - fade_alpha) * (global_state == GLOBAL_STATE_SECRET));
  logo_x_offset = cos(time_precise() * 5) * 2 + 3;
  gfx_x = 165 / 2 - 70 +logo_x_offset; 
  gfx_y = gfx_h / 2 - 30 + logo_y_offset;      
  (global_state == GLOBAL_STATE_MAIN) ? gfx_blit(IMAGE_LOGO, scale, (rand(1) - .5) * .05);
  gfx_mode = 1;
  gfx_a = rand(1) * .4 + (.1 * global_state == GLOBAL_STATE_SECRET);
  gfx_x = 165 / 2 - (70 * 1.1) + logo_x_offset; 
  gfx_y = (gfx_h / 2 - 30) * 0.95 + logo_y_offset;
  gfx_blit(IMAGE_LOGO, scale + 0.1, (rand(1) - .5) * .075);
  gfx_a = 1;
  gfx_mode = 0;      
  //////
  gfx_x = 0;
  gfx_y = 0;
 
  // Fade-in
  (fade_alpha > 0) ? (
    loop(floor(fade_alpha * 10), 
       gfx_dest = IMAGE_COPY;   
       gfx_blit(-1, 1, 0);  
       gfx_blurto(gfx_w, gfx_h);
       gfx_dest = -1;  
       gfx_x = 0;
       gfx_y = 0;
       gfx_blit(IMAGE_COPY, 1, 0); 
     );  
    fade_alpha = max(0, fade_alpha - .1);
    gfx_muladdrect(0,  0, gfx_w, gfx_h, 1 + fade_alpha * 1.05, 1 + fade_alpha, 1 + fade_alpha * 1.5, 1, fade_alpha * 1.5, fade_alpha * 1.4, fade_alpha * 1.6);
  ); 
  
  //Old canvas dimensions
  gfx_w_old = gfx_w;
  gfx_h_old = gfx_h;



desc: monoctrl (Blokatt)
//tags: korg monologue midi
//author: Jan Vorisek

slider1:s_channel=1<1,16,1>MIDI Channel
slider2:s_block_midi_passthrough=1<0,1,1{All events,CC/PC (all events during playback),CC and PC only}>MIDI Passthrough
slider3:s_send_pc_on_init=1:0<0,2,1{On program change and playback start,On program change only,Never (local preset)}>Auto-request program from synth
//================================//
slider5:s_program=1<1,100,1>Program
//================================//
slider7:s_vco1_wave=2<0,1,3{Square,Triangle,Sawtooth}>VCO1 Waveform
slider8:s_vco1_shape=0<0,127,1>VCO1 Shape
//================================//
slider10:s_vco2_wave=2<0,1,3{Noise,Triangle,Sawtooth}>VCO2 Waveform
slider11:s_vco2_shape=0<0,127,1>VCO2 Shape
slider12:s_vco2_pitch=0<-64,63,1>VCO2 Pitch
slider13:s_vco2_octave=0<-1,2,1>VCO2 Octave
//================================//
slider15:s_vco_mode=1<0,1,3{Ring,No sync,Sync}>Sync/Ring
//================================//
slider17:s_vco1_level=127<0,127,1>VCO1 Level
slider18:s_vco2_level=0<0,127,1>VCO2 Level
//================================//
slider20:s_filter_cutoff=127<0,127,1>Filter Cutoff
slider21:s_filter_resonance=0<0,127,1>Filter Resonance
//================================//
slider23:s_lfo_wave=0<0,1,3{Square,Triangle,Sawtooth}>LFO Wave
slider24:s_lfo_mode=0<0,1,3{One shot,Slow,Fast}>LFO Mode
slider25:s_lfo_rate=0<0,127,1>LFO Rate
slider26:s_lfo_intensity=0<-64,63,1>LFO Intensity
slider27:s_lfo_target=0<0,1,3{Cutoff,Shape,Pitch}>LFO Target
//================================//
slider29:s_eg_type=0<0,1,3{Gate,Attack/Gate/Decay,Attack/Decay}>EG Type
slider30:s_eg_attack=0<0,127,1>EG Attack
slider31:s_eg_decay=0<0,127,1>EG Decay
slider32:s_eg_intensity=0<-64,63,1>EG Intensity
slider33:s_eg_target=0<0,1,3{Cutoff,Pitch 2,Pitch}>EG Target
//================================//
slider35:s_drive=0<0,127,1>Drive

filename:0,logo.png
filename:1,background.png

@init  
  function log_print(str) (
    //check overflow & shift
    #str = sprintf(#str, "> %s", str);
    (strcmp(log_line[0], #str) != 0) ? (
      log_current_message_count = min(log_current_message_count + 1, log_max_message_count);    
      b = log_max_message_count - 1;
      loop(log_max_message_count - 1,
        strcpy(log_line[b], log_line[b - 1]);
        log_line_counts[b] = log_line_counts[b - 1];
        b -= 1;
      );   
      strcpy(log_line[0], #str);
      log_line_counts[0] = 0;            
    ) : (      
      log_line_counts[0] += 1;
    );     
    log_redraw = 2;
  );  
  
  function assign_cc() (
    ccid += 1;
    ccid - 1;
  );
  
  function init_cc(id) (
    i = assign_cc();
    cc[i] = id;
    cc_slider[i] = slider_counter + 5;
    cc_slider_old[i] = slider_counter + 5;
    cc_slider_automateid[i] = i + 4;
    slider_counter += 1;
    i;
  );
  
  function invalidate_cc_sliders() ( 
    c = 1;
    loop(cc_count - 2, 
      cc_slider_old[c] = -1;
      c += 1;
    ); 
  );
  function invalidate_sliders() (
    d = 0;
    loop(cc_count - 1, 
      cc_slider_old[d] = -1;
      d += 1;
    ); 
  );
  
  function slider_spacing() (
    slider_counter += 1;
  );
  
  function get_slider(id) (
    slider(cc_slider[id]);
  );
  
  function rand_int(x) (
    min(floor(rand(x + 1)), x);  
  );
  
  function get_slider_automate(id) (
    slider(cc_slider_automateid[id]);
  );
  
  function send_cc(cc, val) (
    cc == -1 ? midisend(0, 0xc0 | (s_channel - 1), val) : midisend(0, 0xb0 | (s_channel - 1), cc, val);    
    midi_event_indicator[MIDI_EVENT_OUT] = 1;
  );
  
  function send_updated_cc(ccid, val) (
    get_slider(ccid) != cc_slider_old[ccid] ? send_cc(cc[ccid], val);
  );
  
  function update_cc_param(ccid, val) (        
    get_slider(ccid) = val;  
    slider_automate(get_slider_automate(ccid));        
  );
  
  function is_switch(cc) (
    (cc == vco2_octave_cc || cc == vco1_wave_cc || cc == vco2_wave_cc || cc == vco_mode_cc ||cc ==  lfo_wave_cc || cc == lfo_mode_cc || cc == lfo_target_cc || cc == eg_type_cc || cc == eg_target_cc);
  ); 
  
  function is_centered_knob(cc) (
    (cc == vco2_pitch_cc || cc == lfo_intensity_cc || cc == eg_intensity_cc);
  ); 
  
  function send_pc_to_device() (
    send_updated_cc(program_cc, s_program - 1); 
  );
  
  function buf_sub_str(bfr, a, b) (
    #str = "";
    e = 0;
    loop(b, 
      sprintf(#str, "%s%c", #str,bfr[a + e]);
      e += 1;
    );    
    #str;      
  );

  function send_cc_to_device() (               
    f = 1;
    loop(cc_count - 1,      
      is_switch(f) ? (
        f == vco2_octave_cc ? (
          send_updated_cc(f, min((get_slider(f) + 1) * 42, 127));   
        ) : (
          send_updated_cc(f, min(get_slider(f) * 64, 127));  
        )
      ) : (           
        (is_centered_knob(f)) ? (   
          send_updated_cc(f, get_slider(f) + 64);                                                          
        ) : (
          send_updated_cc(f, get_slider(f));                                            
        )
      );        
      f += 1;
    );
  );
        
  function update_program(id, update_sliders, send_twice) (  
    send_pc_to_device();
    send = 1000;
    send[0] = 0xf0;
    send[1] = 0x42;
    send[2] = 0x30 | (s_channel - 1);
    send[3] = 0x00;
    send[4] = 0x01;
    send[5] = 0x44;
    send[6] = 0x1c;
    send[7] = s_program - 1;
    send[8] = 0x00;
    send[9] = 0xf7;     
    midisend_buf(0,send,10);               
    program_request_param[id] = (!update_sliders << 1) | send_twice;
    block_slider_update = !update_sliders;
    program_request = update_sliders;
    midi_event_indicator[MIDI_EVENT_OUT] = 1;
  );

  function send_midi() (           
    buf = 10000;
    maxlen = 65536;

    while ((recvlen = midirecv_buf(offset, buf, maxlen)) > 0) (
      event_type = buf[0] >> 4;
      channel = buf[0] & 15;
      
      (recvlen >= 518 && event_type == 0xf && (buf[2] & 15) == s_channel - 1) ? (                               
        offset = 6;
        block_slider_update = 0;        
        program = -1;      
        (buf[offset] == 0x4c) ? (
          program = buf[offset + 1];
          s_program = program + 1;
          block_slider_update = program_request_param[buf[offset + 1]] >> 1;
          offset += 4;
        ) : (
          offset += 2;
        );     
        
        i = 0;

        #temp = buf_sub_str(buf, offset, 4);
        (strcmp(#temp,  "PROG") == 0 && !block_slider_update) ? (                      
          program_request = 0;
          program_request_timer = 0;
          //sprintf(#temp,"%f",rand(5));
          offset += 4;
          
          #temp = "";
          
          last_non_w = 0;
          h = 0;
          valid = 0;
          loop(14,
            (buf[offset + h] != 0 && h != 11)? (
              sprintf(#temp, "%s%c", #temp, buf[offset + h]);
              (buf[offset + h] != ' ') ? last_non_w = h;
              valid += 1;
            ); 
            h += 1;
          );             
          
          strcpy(#temp2, #temp);  
          #temp = strcpy_substr(#temp, #temp2, 0, last_non_w);
             
          ///// vco1 level
          offset += 11;        
          value = ((buf[offset] & 64) << 3);
          value = value | ((buf[offset + 7] & 127) << 2);
          value = value | (buf[offset + 22] & 3);
          update_cc_param(vco1_level_cc, value >> 3);
                    
          /////vco2 shape
          value = ((buf[offset] & 32) << 4);
          value = value | ((buf[offset + 6] & 127) << 2);
          value = value | ((buf[offset + 20] & 12) >> 2);
          update_cc_param(vco2_shape_cc, value >> 3);  
                    
          ///// vco2 pitch
          value = ((buf[offset] & 16) << 5);
          value = value | ((buf[offset + 5] & 127) << 2);
          value = value | (buf[offset + 20] & 3);  
          update_cc_param(vco2_pitch_cc, value >> 3 - 64);      
          
          ///// vco1 shape
          value = ((buf[offset] & 8) << 6);
          value = value | ((buf[offset + 4] & 127) << 2);
          value = value | ((buf[offset + 19] & 12) >> 2);        
          update_cc_param(vco1_shape_cc, value >> 3);
          
          ///// lfo rate
          offset += 8;        
          value = (buf[offset] & 64) << 3;
          value = value | ((buf[offset + 7] & 127) << 2);
          value = value | ((buf[offset + 17] & 12) >> 2);    
          update_cc_param(lfo_rate_cc, value >> 3);    
          
          ///// eg intensity
          value = (buf[offset] & 32) << 4;
          value = value | ((buf[offset + 6] & 127) << 2);
          value = value | (buf[offset + 17] & 3);
          update_cc_param(eg_intensity_cc, (value >> 3) - 64);          
          
          ///// eg decay
          value = (buf[offset] & 16) << 5;
          value = value | ((buf[offset + 5] & 127) << 2);
          value = value | ((buf[offset + 15] & 48) >> 4);
          update_cc_param(eg_decay_cc, value >> 3);
                    
          ///// eg attack
          value = (buf[offset] & 8) << 6;
          value = value | ((buf[offset + 4] & 127) << 2);
          value = value | ((buf[offset + 15] & 12) >> 2);      
          update_cc_param(eg_attack_cc, value >> 3);  
          
          ///// filter resonance
          value = (buf[offset] & 4) << 7;
          value = value | ((buf[offset + 3] & 127) << 2);
          value = value | ((buf[offset + 8] & 32) >> 4);
          value = value | ((buf[offset + 14] & 64) >> 6);    
          update_cc_param(resonance_cc, value >> 3);   
          
          ///// filter cutoff
          value = (buf[offset] & 2) << 8;
          value = value | ((buf[offset + 2] & 127) << 2);
          value = value | ((buf[offset + 14] & 48) >> 4);
          update_cc_param(cutoff_cc, value >> 3);          
          
          ///// vco2 level
          value = ((buf[offset] & 1) << 9);
          value = value | ((buf[offset + 1] & 127) << 2);
          value = value | (buf[offset + 14] & 12) >> 2;
          update_cc_param(vco2_level_cc, value >> 3);          
          
          ///// eg target
          offset += 8;        
          value = (buf[offset] & 64) >> 5;
          value = value | ((buf[offset + 7] & 64) >> 6);
          update_cc_param(eg_target_cc, value);
          
          ///// vco2 wave
          value = ((buf[offset] & 8) >> 2);
          value = value | ((buf[offset + 4] & 64) >> 6);
          update_cc_param(vco2_wave_cc, value);
          
          ///// vco1 wave
          value = ((buf[offset] & 4) >> 1);
          value = value | ((buf[offset + 3] & 64) >> 6);
          update_cc_param(vco1_wave_cc, value);
          
          ///// drive
          value = ((buf[offset] & 2) << 8);
          value = value | ((buf[offset + 2] & 127) << 2);
          value = value | ((buf[offset + 8] & 1) << 1);
          value = value | ((buf[offset + 9] & 64) >> 6);
          update_cc_param(drive_cc, value >> 3);
          
          ///// lfo intensity
          value = (buf[offset] & 1) << 9;
          value = value | ((buf[offset + 1] & 127) << 2);
          value = value | ((buf[offset + 9] & 48) >> 4);
          update_cc_param(lfo_intensity_cc, (value >> 3) - 64);
          
          ///// vco2 octave
          offset += 4;
          value = (buf[offset] & 48) >> 4;
          update_cc_param(vco2_octave_cc, value - 1);
          
          ///// ring/sync
          offset += 1;
          value = (buf[offset] & 3);
          update_cc_param(vco_mode_cc, value);
          
          ///// eg type
          offset += 2;        
          value = (buf[offset] & 3);     
          update_cc_param(eg_type_cc, value );
          
          ///// lfo target    
          offset += 3;        
          value = (buf[offset] & 48) >> 4;
          update_cc_param(lfo_target_cc, value);
          
          ///// lfo mode
          value = (buf[offset] & 12) >> 2;
          update_cc_param(lfo_mode_cc, value);
          
          ///// lfo wave
          value = (buf[offset] & 3);
          update_cc_param(lfo_wave_cc, value);
          (program != -1) ? (
            (program_request_param[program] & 1) ?  echo_program_request = 5;
            //program_request_param[program] = 0;
          );
          (program == -1 || (program >= 0 && !program_request_param[program] & 1)) ? ( 
            log_print(sprintf(#, "RECV: Program %d: '%s'", s_program, #temp)); 
          ); 
          midi_event_indicator[MIDI_EVENT_IN] = 1;  
        );      
        
        /*
          The synth won't accept CC for a while after
          transmitting program data, so we wait a bit
          before sending all the sliders back to it.
          (precision consistency, non-updated sliders, etc...)  
        */
        send_cc_delay = 1;
        send_cc_timer = srate * .1;

        block_slider_update = 0;    
        i = 1;
        loop(cc_count - 1, 
          cc_slider_old[i] = get_slider(i);
          i += 1;
        );                 
      ) : ( 
        (channel == s_channel - 1) ? (
          (event_type == 0xb) ? (
            val =  buf[2];
            g = 1;
            loop(cc_count - 1, 
              buf[1] == cc[g] ? (
                is_switch(g) ? (
                  g == vco2_octave_cc ? (
                    get_slider(g) = floor((val) / 42) - 1;   
                  ) : (
                    get_slider(g) = floor((val + 1) / 64);   
                  )
                ) : (           
                  (is_centered_knob(g)) ? (   
                    get_slider(g) = val - 64;                                                            
                  ) : (
                    get_slider(g) = val;                                            
                  )
                );
                slider_automate(get_slider_automate(g));        
                midi_event_indicator[MIDI_EVENT_IN] = 1;  
              );
              g += 1;
            );  
            
          ) : ( //program change
            (event_type == 0xc) ? (            
              get_slider(program_cc) = buf[1] + 1;  
              slider_automate(get_slider(program_cc));                   
              midi_event_indicator[MIDI_EVENT_IN] = 1;
            ) : (                 
              ((s_block_midi_passthrough == 0) || (s_block_midi_passthrough == 1 && play_state  == 1)) ? (
                midisend_buf(offset,buf,recvlen);               
                midi_event_indicator[MIDI_EVENT_IN] = 1;
                midi_event_indicator[MIDI_EVENT_OUT] = 1;
              );
            );
          );
        );            
      ); 
    );    
                       
    send_cc_to_device();
     
    (button_clicked[3]) ? update_program(s_program -  1, 1, 1);
    (button_clicked[2]) ? (
      update_program(s_program - 1, 0, 1);
    );  
    
    (button_clicked[0]) ? (
      update_cc_param(vco1_wave_cc, min(2, max(0, s_vco1_wave + rand_int(2) - 1)));
      update_cc_param(vco1_shape_cc, min(127, max(0, s_vco1_shape + rand_int(10) - 5)));          
      update_cc_param(vco2_wave_cc, min(2, max(0, s_vco2_wave + rand_int(2) - 1)));
      update_cc_param(vco2_shape_cc,  min(127, max(0, s_vco2_shape + rand_int(10) - 5)));          
      update_cc_param(vco2_pitch_cc, min(63, max(-64, s_vco2_pitch + rand_int(10) - 5)));  
      update_cc_param(vco2_octave_cc, min(2, max(-1, s_vco2_octave + rand_int(2) - 1)));
      update_cc_param(vco_mode_cc, min(2, max(0, s_vco_mode + rand_int(2) - 1)));
      update_cc_param(vco1_level_cc, min(127, max(0, s_vco1_level + rand_int(10) - 5)));          
      update_cc_param(vco2_level_cc, min(127, max(0, s_vco2_level + rand_int(10) - 5)));          
      update_cc_param(cutoff_cc, min(127, max(0, s_filter_cutoff + rand_int(10) - 5)));          
      update_cc_param(resonance_cc, min(127, max(0, s_filter_resonance + rand_int(10) - 5)));         
      update_cc_param(lfo_wave_cc, min(2, max(0, s_lfo_wave + rand_int(2) - 1)));
      update_cc_param(lfo_mode_cc, min(2, max(0, s_lfo_mode + rand_int(2) - 1)));
      update_cc_param(lfo_rate_cc, min(127, max(0, s_lfo_rate + rand_int(10) - 5)));    
      update_cc_param(lfo_intensity_cc, min(63, max(-64, s_lfo_intensity + rand_int(10) - 5)));  
      update_cc_param(lfo_target_cc, min(2, max(0, s_lfo_target + rand_int(2) - 1)));
      update_cc_param(eg_type_cc ,min(2, max(0, s_eg_type + rand_int(2) - 1)));          
      update_cc_param(eg_attack_cc, min(127, max(0, s_eg_attack + rand_int(6) - 3)));    
      update_cc_param(eg_decay_cc, min(127, max(0, s_eg_decay + rand_int(10) - 5)));    
      update_cc_param(eg_intensity_cc, min(63, max(-64, s_eg_intensity + rand_int(10) - 5)));  
      update_cc_param(eg_target_cc, min(2, max(0, s_eg_target + rand_int(2) - 1)));
      update_cc_param(drive_cc, min(127, max(0, s_drive + rand_int(10) - 5)));         
      log_print("Sliders mutated.");
      invalidate_cc_sliders();       
      send_cc_to_device();
    );
    
    (button_clicked[1]) ? (
      update_cc_param(vco1_wave_cc, rand_int(2));
      update_cc_param(vco1_shape_cc, rand_int(0x7f));        
      update_cc_param(vco2_wave_cc, rand_int(2));
      update_cc_param(vco2_shape_cc, rand_int(0x7f));
      update_cc_param(vco2_pitch_cc, -64 + rand_int(0x7f));
      update_cc_param(vco2_octave_cc, -1 + rand_int(3));        
      update_cc_param(vco_mode_cc, rand_int(2));        
      update_cc_param(vco1_level_cc, rand_int(0x7f));
      update_cc_param(vco2_level_cc, rand_int(0x7f));        
      update_cc_param(cutoff_cc, rand_int(0x7f));
      update_cc_param(resonance_cc, rand_int(0x7f));        
      update_cc_param(lfo_wave_cc, rand_int(2));
      update_cc_param(lfo_mode_cc, rand_int(2));
      update_cc_param(lfo_rate_cc, rand_int(127));
      update_cc_param(lfo_intensity_cc, -64 + rand_int(0x7f));
      update_cc_param(lfo_target_cc,  rand_int(2));        
      update_cc_param(eg_type_cc, rand_int(2));
      update_cc_param(eg_attack_cc,  floor(min(pow(rand(1), 8) * 0x7f, 0x7f)));
      update_cc_param(eg_decay_cc, floor(min(0x7f - pow(rand(1), 5) * 0x7f, 0x7f)));
      update_cc_param(eg_intensity_cc, -64 + rand_int(0x7f));
      update_cc_param(eg_target_cc, rand_int(2));
      update_cc_param(drive_cc, rand_int(0x7f));
      log_print("Sliders randomised.");
      invalidate_cc_sliders();       
      send_cc_to_device();
    );    
  );
            
  function on_playback_start() (
    invalidate_cc_sliders(); 
    send_cc_to_device();
    (s_send_pc_on_init == 0) ? update_program(s_program - 1, 1, 1);
  );
    
  function update() (          
    send_midi();
    cc_changed = 0;
    k = 1;
    loop(cc_count - 1,
      (get_slider(k) != cc_slider_old[k]) ? cc_changed = 1;
      k += 1;
    );
    //(cc_changed) ? block_slider_update = 1;
                
  
    l = 0;
    loop(10,  
      button_clicked[l] = 0;
      l += 1;
    );
    
    // Delayed CC sending
    (send_cc_delay) ? (
      (!send_cc_timer) ? (
        invalidate_cc_sliders(); 
        send_cc_to_device();  
        send_cc_delay = 0;
      );
      send_cc_timer = max(0, send_cc_timer - samplesblock);
    );   
            
    (play_state && !last_play_state) ? (
      //started playback
      on_playback_start();
    );
              
    (echo_program_request > 0) ? (
      (echo_program_request == 1) ? (
        update_program(s_program - 1, !(program_request_param[s_program - 1] >> 1), 0);      
      );
      echo_program_request -= 1;
    );
    
    (s_program != s_program_old) ? (  
      update_program(s_program - 1, !cc_changed && (s_send_pc_on_init != 2), 1);                      
    ); 
      
    s_program_old = s_program;
    (program_request) ? (
      program_request_timer += samplesblock;
      (program_request_timer > srate) ? (
        log_print("ERROR: Program request failed! Check your synth settings and make sure MIDI input is enabled on all channels in order to receive SySex messages.");
        program_request_timer = 0;
        program_request = 0;
      );
    );    
        
    
    last_play_state = play_state;
    
    m = 1;
    loop(cc_count - 1, 
      cc_slider_old[m] = get_slider(m);
      m += 1;
    );
  );

  ext_noinit = 1.0;
  backw = 0;
  backh = 0;

  cc_count = 23;
  cc = 0;
  
  // memory offsets
  cc_slider = 100;
  cc_slider_old = 200;
  cc_slider_automateid = 300; 
  log_line = 400;
  log_line_counts = 500;
  button_clicked = 600;
  program_request_param = 700;
  midi_event_indicator = 900;
  //
  MIDI_EVENT_OUT = 0;  
  MIDI_EVENT_IN = 1;  
  
  
  //testing for successful program request
  program_request = 0; 
  program_request_timer = 0;
  //
  button_redraw = 5;
   
  //100 messages
  
  a = 0; 
  loop(99,
    log_line[a] = 200 + a;
    a += 1;
  );
  //
  log_redraw = 1;
  log_max_message_count = 99;
  log_horizontal_offset = 200;
  
  send_cc_timer = 0;
  send_cc_delay = 0;
  
  ccid = 0;
  slider_counter = 0;
  last_play_state = 0;

  gfx_w_old = gfx_w;
  gfx_h_old = gfx_w;

  
    
  update();
  (s_send_pc_on_init != 2) ? send_pc = 1;
  
  /*
  init order must be same as slider order!
  */     
  program_cc = init_cc(-1);
  slider_spacing();
 
  vco1_wave_cc = init_cc(50);      
  vco1_shape_cc = init_cc(36);
  
  slider_spacing();
 
  vco2_wave_cc = init_cc(51);    
  vco2_shape_cc = init_cc(37);
  vco2_pitch_cc = init_cc(35);
  vco2_octave_cc = init_cc(49);
  
  slider_spacing();
  
  vco_mode_cc = init_cc(60);
  
  slider_spacing();
  
  vco1_level_cc = init_cc(39);
  vco2_level_cc = init_cc(40);
  
  slider_spacing();
  
  cutoff_cc = init_cc(43);
  resonance_cc = init_cc(44);
  
  slider_spacing();
  
  lfo_wave_cc = init_cc(58);
  lfo_mode_cc = init_cc(59);  
  lfo_rate_cc = init_cc(24);
  lfo_intensity_cc = init_cc(26);  
  lfo_target_cc = init_cc(56);
  
  slider_spacing();
  
  eg_type_cc = init_cc(61);
  eg_attack_cc = init_cc(16);  
  eg_decay_cc = init_cc(17);
  eg_intensity_cc = init_cc(25);  
  eg_target_cc = init_cc(62);  
  
  slider_spacing();
  drive_cc = init_cc(28);  
  
  log_print("====================================================");   
  log_print("Set input to:");
  log_print("MIDI -> Monologue KBD/KNOB -> All channels");
  log_print("Set hardware MIDI output to:");
  log_print("Monologue SOUND (low precision)");
  log_print("Enable input monitoring and arm this track.");   
  log_print("====================================================");     
  
  s_program_old = s_program;
  update_program(s_program - 1, 0, 1);


@block
  update();        

@gfx 560, 110
  function draw_button(x, y, str, id) (
    gfx_x = x;
    gfx_y = y;
    gfx_measurestr(str, w, h);
    gfx_set(.25, .25, .25);
    gfx_set(.1, .1, .1);
    x0 = gfx_x - w - 5;
    y0 = gfx_y - h / 2 - 2;
    w += 10;
    h += 3;
    
    (!(mouse_cap & 1)) ? (
      released = 1;
    );       
    
    gfx_rect(x0, y0, w, h, 1); 
    
    gfx_gradrect(x0, y0, w, h, .5, .2, .7, 1, 0, 0, 0, 0, -.03, -.03, -.03, 0);
    
    gfx_mode = 1;
    gfx_set(1., 0, 0, -1, 1);
    gfx_rect(x0 + 1, y0 + 1, w  - 2, h - 2, 0); 
    gfx_mode = 0;
    gfx_set(.6, .4, .85);
    gfx_rect(x0, y0, w, h, 0); 
    gfx_mode = 0;
    gfx_set(.9, .8, 1);
    
    (mouse_x >= x0 && mouse_y >= y0 && mouse_x <= x0 + w && mouse_y <= y0 + h) ? (      
      gfx_mode = 1;
      gfx_gradrect(x0, y0, w, h, .4, .1, .8, .75, 0, 0, 0, 0, -.03, -.03, -.03, 0);
      gfx_mode = 0;
      gfx_setcursor(32649);
      gfx_set(1, 1, 1);
      (mouse_cap & 1) ? (
        gfx_y += 1;
        gfx_mode = 1;
        gfx_gradrect(x0, y0, w, h, .6, .1, .2, -.25, 0, 0, 0, 0, -.03, -.03, -.03, 0);
        gfx_mode = 0;
        (button_clicked[id] == 0 && released) ? (
          button_clicked[id] = 1;      
          released = 0;
        );
      );        
    );
    
    gfx_drawstr(str, 42|256, gfx_x, gfx_y + 5);
  );
  
  function draw_event_indicator(x, y, id) ( 
      gfx_set(.03, 0, .22);
      gfx_circle(x, y, 3, 1, 1);
      gfx_set(.15, .1, .6);
      gfx_circle(x, y, 3, 0, 1);     
 
      gfx_mode = 1;
      midi_event_indicator[id] = max(0, midi_event_indicator[id] - .2);
      gfx_set(.88, .315, 1, midi_event_indicator[id]);      
      gfx_circle(x, y, 1 + midi_event_indicator[id], 1, 1);
      gfx_mode = 0;
  
      gfx_set(.9, .8, 1);
      gfx_circle(x, y, 4, 0, 1);    
      
      side = 1 - 2 * id;
      gfx_set(.5, .4, 1, .5);
      gfx_triangle(x - 15, y + 3 * side - side, x - 12, y - 3 * side + side, x - 9, y + 3 * side - side);
      gfx_set(.5, .4, 1);
      gfx_triangle(x - 15, y + 3 * side, x - 12, y - 3 * side, x - 9, y + 3 * side);
      gfx_set(1, 1, 1, 1);
      gfx_triangle(x - 14, y + 2 * side, x - 12, y - 2 * side, x - 10, y + 2 * side);
    );

  gfx_clear = 0;
  
  (mouse_y <= 25 && mouse_y >= 0) ? (
    button_redraw = 5;
  );
  
  (gfx_w_old != gfx_w || gfx_h_old != gfx_h) ? (
    log_redraw = 2;
    console_redraw = 5;
  );
  
  gfx_setimgdim(3, gfx_w, gfx_h);  
  gfx_setimgdim(2, gfx_w, gfx_h);
  gfx_getimgdim(1, backw, backh); 
  repeats = ceil((gfx_h + 20) / backh);
  i = 0;
  gfx_x = 0;
  off = (time_precise() * 20) % 20;
  loop(repeats,   
    gfx_y = floor(backh * i - off);
    gfx_blit(1, 1, 0);
    i += 1;
  );
  
  scale = 1;
  gfx_setfont(1, "Courier New", 13);
  
  log_max_message_count = floor(gfx_h / 10) - 3;  
  
  (log_redraw) ? (
    gfx_x = 0;
    gfx_y = 0;
   
    gfx_dest = 2;   
    gfx_muladdrect(0, 0, gfx_w, gfx_h, 1, 1, 1, 0);     
    gfx_clear = 0;
   
    i = 0;
    gfx_y = gfx_h - 20;    
    
    max_len = (gfx_w - log_horizontal_offset - 20) / 6;    
    line_breaks = 0;        
    
    loop(log_max_message_count,
      (line_breaks < log_max_message_count) ? (         
        #line = "";
        strcpy(#line, log_line[i]);
        (log_line_counts[i] > 0) ? sprintf(#line, "%s (%d)", #line, log_line_counts[i]); 
        
        gfx_set(1, 1, 1);
        (match("> ERROR:*", #line)) ? gfx_set(1, 0, 0);
        
        len = strlen(#line);      
        off = 0;
        premature_break = 0;
        line_off = 0;
        local_line_breaks = 0;
        #broken_line = "";
       
        ///// assemble broken up line
        loop(len,
          (str_getchar(#line, off) != ' ') ? (
            (!read_word) ? (
              j = 0;
              break = 0;
              while (!break && j <= len)(
                ((line_off + j) > max_len) ? (                  
                  premature_break = 1;       
                             
                  break = 1;              
                );
                (j > 15 || str_getchar(#line, off + j) == ' ') ? break = 1;
                j += 1;              
              );
              read_word = 1;
            );
          ) : (
            read_word = 0;                        
          );
          
          ((line_off > max_len || premature_break)) ? (
            line_off = 0;
            local_line_breaks += 1;
            premature_break = 0;
            sprintf(#broken_line, "%s\n", #broken_line);
          ); 
          sprintf(#broken_line, "%s%c", #broken_line, str_getchar(#line, off));
          off += 1;
          line_off += 1;
        );
        /////////////////        
        message_vertical_offset = local_line_breaks * 10;
        
        ///// print
        gfx_x = log_horizontal_offset;        
        gfx_y -= message_vertical_offset;
        
        off = 0;
        loop(strlen(#broken_line), 
          char = str_getchar(#broken_line, off);
          (char == '\n') ? (
            gfx_x = log_horizontal_offset;
            gfx_y += 10;
          ) : (
            gfx_drawchar(char);
          );
          off += 1;
        );
        gfx_y -= message_vertical_offset + 10;
        /////////////////   
        i += 1;
        line_breaks += 1;
      );
    );
    gfx_set(0.0, 0.0, 0.0);                    
    gfx_rect(log_horizontal_offset, 0, gfx_w - log_horizontal_offset, 25);
    gfx_gradrect(log_horizontal_offset, 25, gfx_w - log_horizontal_offset, 6, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -.166);
    gfx_set(1.0, 1.0, 1.0);      
    
    gfx_dest = -1;
    
    
  );
  
  gfx_set(1., 1., 1., 1.);
  
  (button_redraw || log_redraw) ? (
    gfx_dest = 2;
    x_offset = gfx_w - 10;
    draw_button(x_offset, 13, "MUTATE", 0);
    x_offset -= w + 5;
    draw_button(x_offset, 13, "RANDOMISE", 1);
    x_offset -= w + 5;
    draw_button(x_offset, 13, "SEND", 2);
    x_offset -= w + 5;
    draw_button(x_offset, 13, "GET", 3);
    gfx_dest = -1;
    
  );
  button_redraw = max(0, button_redraw - 1);
  log_redraw = max(0, log_redraw - 1);
  
  gfx_x = 6;
  gfx_y = gfx_h - 2;
  //gfx_drawnumber(rand(100), 10);
  
  gfx_drawstr("blokatt.net | @blokatt | 2019.", 8|256, gfx_x, gfx_y);
    
  gfx_x = 30;
  gfx_y = 10;
  //gfx_drawstr(#temp); 
  gfx_x = 30;
  gfx_y = 20;

  gfx_x = 10 + sin(time_precise() * 5) * 2; 
  gfx_y = gfx_h / 2 - 30;
    
  gfx_blit(0, scale, (rand(1) - .5) * .05);
  gfx_mode = 1;
  gfx_a = rand(1) * .4;
  gfx_x = 165 / 2 - (73.5 * 1.1);
  gfx_y = (gfx_h / 2 - 30) * 0.95;
  gfx_blit(0, scale + 0.1, (rand(1) - .5) * .075);
  gfx_a = 1;
  gfx_mode = 0;
  
  gfx_x = 0;
  gfx_y = 0;
  
  
  gfx_set(1, 1, 1, 1);
  gfx_blit(2, 1, 0);
  
  gfx_setcursor(32512);
 
  (x_offset > log_horizontal_offset + 80) ? (
    draw_event_indicator(log_horizontal_offset + 15, 12, MIDI_EVENT_IN); 
    draw_event_indicator(log_horizontal_offset + 46, 12, MIDI_EVENT_OUT); 
  );
  gfx_rect(1, 1, gfx_w - 1, gfx_h - 1,0);
  
  gfx_w_old = gfx_w;
  gfx_h_old = gfx_h;


